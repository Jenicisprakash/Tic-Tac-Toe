# Tic-Tac-Toe

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e5e7eb;
        }
        .board-cell {
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s;
            border-radius: 0.5rem;
        }
        .board-cell:hover:not(.occupied) {
            background-color: #374151;
        }
        .board-cell.occupied {
            cursor: not-allowed;
        }
        #gameBoard {
            border: none;
        }
        #gameBoard .grid-cell:not(:nth-child(3n)) {
            border-right: 4px solid #4b5563;
        }
        #gameBoard .grid-cell:nth-child(n+1):nth-child(-n+6) {
            border-bottom: 4px solid #4b5563;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(17, 24, 39, 0.9);
            padding: 2.5rem;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            color: #e5e7eb;
            text-align: center;
        }
        .message-box.show {
            display: flex;
        }
        .suggested-move {
            background-color: #1d4ed8;
            box-shadow: 0 0 20px 8px rgba(59, 130, 246, 0.6);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">
    <div class="flex flex-col items-center justify-center p-4 min-h-screen w-full">
        <h1 class="text-5xl font-extrabold mb-8 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-teal-400" </h1>

        <div id="gameContainer" class="flex flex-col items-center">
            <div id="gameMessage" class="text-2xl mb-6 font-semibold text-center h-8 text-gray-300">
                Your turn (X)
            </div>

            <div id="gameBoard" class="grid grid-cols-3 gap-2 p-2 bg-gray-800/50 rounded-xl shadow-2xl">
                <!-- Cells will be generated by JavaScript -->
            </div>

            <div class="mt-8 flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
                <button id="suggestMoveButton" class="px-6 py-3 bg-gradient-to-r from-purple-500 to-indigo-500 text-white text-lg font-bold rounded-full shadow-lg hover:from-purple-600 hover:to-indigo-600 focus:outline-none focus:ring-4 focus:ring-indigo-300 transform transition-transform duration-200 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed">
                    ✨ Suggest a Move
                </button>
                <button id="resetButton" class="px-8 py-3 bg-gradient-to-r from-green-500 to-blue-500 text-white text-lg font-bold rounded-full shadow-lg hover:from-green-600 hover:to-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300 transform transition-transform duration-200 active:scale-95">
                    Reset Game
                </button>
            </div>
        </div>

        <div id="customMessageBox" class="message-box">
            <p id="messageContent" class="text-3xl font-bold mb-6"></p>
            <button id="messageBoxOkButton" class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                OK
            </button>
        </div>
    </div>

    <script>
        // Game variables
        let board = [];
        let currentPlayer = 'X';
        let gameActive = true;
        let aiThinking = false;

        // DOM elements
        const gameBoardElement = document.getElementById('gameBoard');
        const gameMessageElement = document.getElementById('gameMessage');
        const resetButton = document.getElementById('resetButton');
        const suggestMoveButton = document.getElementById('suggestMoveButton');
        const customMessageBox = document.getElementById('customMessageBox');
        const messageContent = document.getElementById('messageContent');
        const messageBoxOkButton = document.getElementById('messageBoxOkButton');

        function initializeBoard() {
            return Array(3).fill(null).map(() => Array(3).fill(' '));
        }
        
        function renderBoard() {
            gameBoardElement.innerHTML = '';
            board.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const cellElement = document.createElement('div');
                    cellElement.classList.add('board-cell', 'grid-cell');
                    cellElement.dataset.row = rowIndex;
                    cellElement.dataset.col = colIndex;
                    cellElement.textContent = cell === ' ' ? '' : cell;

                    if (cell !== ' ') {
                        cellElement.classList.add('occupied');
                        cellElement.classList.add(cell === 'X' ? 'text-blue-400' : 'text-red-400');
                    } else {
                        cellElement.classList.add('text-gray-400');
                    }
                    cellElement.addEventListener('click', handleCellClick);
                    gameBoardElement.appendChild(cellElement);
                });
            });
        }
        
        function showMessage(msg, callback = null) {
            messageContent.textContent = msg;
            customMessageBox.classList.add('show');
            gameActive = false;
            messageBoxOkButton.onclick = () => {
                customMessageBox.classList.remove('show');
                if (callback) callback();
            };
        }

        function checkWinner(currentBoard, player) {
            const lines = [
                [[0,0],[0,1],[0,2]], [[1,0],[1,1],[1,2]], [[2,0],[2,1],[2,2]],
                [[0,0],[1,0],[2,0]], [[0,1],[1,1],[2,1]], [[0,2],[1,2],[2,2]],
                [[0,0],[1,1],[2,2]], [[0,2],[1,1],[2,0]]
            ];
            for (const line of lines) {
                if (line.every(([r,c]) => currentBoard[r][c] === player)) {
                    return true;
                }
            }
            return false;
        }

        function isFull(currentBoard) {
            return currentBoard.flat().every(cell => cell !== ' ');
        }

        function getBestMove(currentBoard) {
            function minimax(board, depth, isMaximizing) {
                if (checkWinner(board, 'O')) return 10 - depth;
                if (checkWinner(board, 'X')) return depth - 10;
                if (isFull(board)) return 0;

                let bestScore = isMaximizing ? -Infinity : Infinity;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (board[i][j] === ' ') {
                            board[i][j] = isMaximizing ? 'O' : 'X';
                            let score = minimax(board, depth + 1, !isMaximizing);
                            board[i][j] = ' ';
                            bestScore = isMaximizing ? Math.max(score, bestScore) : Math.min(score, bestScore);
                        }
                    }
                }
                return bestScore;
            }

            let bestScore = -Infinity;
            let move = null;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (currentBoard[i][j] === ' ') {
                        currentBoard[i][j] = 'O';
                        let score = minimax(currentBoard, 0, false);
                        currentBoard[i][j] = ' ';
                        if (score > bestScore) {
                            bestScore = score;
                            move = [i, j];
                        }
                    }
                }
            }
            return move;
        }

        async function handleCellClick(event) {
            if (!gameActive || aiThinking || currentPlayer !== 'X') return;

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            if (board[row][col] === ' ') {
                board[row][col] = 'X';
                renderBoard();

                if (checkWinner(board, 'X')) {
                    showMessage('Congratulations! You win!', resetGame);
                    updateButtonStates(true);
                    return;
                }
                if (isFull(board)) {
                    showMessage("It's a draw!", resetGame);
                    updateButtonStates(true);
                    return;
                }

                switchPlayerToAI();
            }
        }
        
        function switchPlayerToAI() {
            currentPlayer = 'O';
            gameMessageElement.textContent = "AI's turn (O)...";
            aiThinking = true;
            updateButtonStates(true);

            setTimeout(() => {
                const aiMove = getBestMove(board);
                if (aiMove) {
                    board[aiMove[0]][aiMove[1]] = 'O';
                    renderBoard();

                    if (checkWinner(board, 'O')) {
                        showMessage('AI wins! Better luck next time.', resetGame);
                        aiThinking = false;
                        updateButtonStates(true);
                        return;
                    }
                    if (isFull(board)) {
                        showMessage("It's a draw!", resetGame);
                        aiThinking = false;
                        updateButtonStates(true);
                        return;
                    }
                }
                switchPlayerToHuman();
            }, 700);
        }

        function switchPlayerToHuman() {
            currentPlayer = 'X';
            gameMessageElement.textContent = "Your turn (X)";
            aiThinking = false;
            updateButtonStates(false);
        }
        
        async function handleSuggestMove() {
            if (currentPlayer !== 'X' || !gameActive) return;

            updateButtonStates(true);
            suggestMoveButton.innerHTML = `
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Thinking...`;

            try {
                const suggestion = await getGeminiSuggestion();
                if (suggestion && board[suggestion.row][suggestion.col] === ' ') {
                    highlightSuggestion(suggestion.row, suggestion.col);
                } else {
                    showMessage("Couldn't find a valid move.", null)
                }
            } catch (error) {
                console.error("Error getting suggestion:", error);
                showMessage("Could not get suggestion.", null);
            } finally {
                updateButtonStates(false);
                suggestMoveButton.innerHTML = "✨ Suggest a Move";
            }
        }

        async function getGeminiSuggestion() {
            // Use the built-in AI to suggest moves
            const tempBoard = board.map(row => [...row]);
            const move = getBestMove(tempBoard);
            return move ? { row: move[0], col: move[1] } : null;
        }

        function highlightSuggestion(row, col) {
            const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cellElement) {
                cellElement.classList.add('suggested-move');
                setTimeout(() => {
                    cellElement.classList.remove('suggested-move');
                }, 3000);
            }
        }
        
        function updateButtonStates(isDisabled) {
            suggestMoveButton.disabled = isDisabled || currentPlayer !== 'X' || !gameActive;
            resetButton.disabled = isDisabled && aiThinking;
        }

        function resetGame() {
            board = initializeBoard();
            gameActive = true;
            aiThinking = false;
            switchPlayerToHuman();
            renderBoard();
        }

        // Initialize
        resetButton.addEventListener('click', resetGame);
        suggestMoveButton.addEventListener('click', handleSuggestMove);
        document.addEventListener('DOMContentLoaded', resetGame);
    </script>
</body>
</html>
